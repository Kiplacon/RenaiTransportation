------------------- keikaku ----------------------
-- add item requesting
-- add crafting action
-- add take item action
-- add


--- Adding a new action: add goal, add goal name to colonist goal list, add evals/reservations, add reqs & solving actions, add effects, add difficulty

if script.active_mods["gvv"] then require("__gvv__.gvv")() end



script.on_init(
   require("script.on_init")
)

require("script.functions") -- a bunch of functions
require("script.ColonistFunctions.ReferenceLists")
require("script.ColonistFunctions.CalculatingPlans")
require("script.ColonistFunctions.RunningPlans")

script.on_event(
	{
		defines.events.on_built_entity,
		defines.events.script_raised_built,
		defines.events.on_entity_cloned,
		defines.events.on_robot_built_entity,
	},
	require("script.on_build")
)

script.on_event(defines.events.on_entity_destroyed,
   require("script.on_destroyed")
)

--script.on_nth_tick(60,
script.on_event(defines.events.on_tick,
--script.on_event("DebugAdvanceActionProcess",
	require("script.on_tick")
)


script.on_event("DebugAdvanceActionProcess",
function()
   local PlayerProperties = global.test.player
   local selected = global.test.selected
   local start = PlayerProperties.variables.StartPole
   local finish = selected
   if open == nil then
      open = {{entity=start, g=0, h=DistanceBetween(start.position, finish.position), f=DistanceBetween(start.position, finish.position)}}
      closed = {}
      found = false
   end
   local step = global.test.step
   --while (found == false) do
   if found == false then
      local current = open[#open]
      game.print(step)
      local ID = #open
      for each, option in pairs(open) do
         if (option.f <= current.f and option.h < current.h) then
            current = option
            ID = each
         end
      end
      game.print(ID)
      open[ID] = nil
      closed[current.entity.unit_number] = current

      if (current.entity.unit_number == finish.unit_number) then
         found = true
         --break
      end

      for each, neighbor in pairs(current.entity.neighbours["copper"]) do
         local g = current.g + DistanceBetween(current.entity.position, neighbor.position)
         if (closed[neighbor.unit_number] == nil and (open[neighbor.unit_number] == nil or open[neighbor.unit_number].g > g)) then
            rendering.draw_text{
               text=each,
               surface=neighbor.surface,
               target=neighbor,
               color={1,1,1},
               time_to_live = 60
            }
            local f = g + DistanceBetween(neighbor.position, finish.position)
            table.insert(open, {entity=neighbor, g=g, h=DistanceBetween(neighbor.position, finish.position), f=f, parent=current.entity})
         end
      end
      global.test.step = step+1
   --end
   elseif (found == true) then
      local backtrack = false
      local path = {}
      local WhereDidYouComeFrom = finish
      table.insert(path, WhereDidYouComeFrom)
      while (backtrack == false) do
         WhereDidYouComeFrom = closed[WhereDidYouComeFrom.unit_number].parent
         table.insert(path, WhereDidYouComeFrom)
         if (WhereDidYouComeFrom.unit_number == start.unit_number) then
            backtrack = true
         end
      end
      for each, entity in pairs(path) do
         rendering.draw_text{
            text=each,
            surface=entity.surface,
            target=entity,
            color={1,1,1}
         }
      end
      PlayerProperties.action = "none"
      PlayerProperties.variables = {}
   end
end)
script.on_event(defines.events.on_ai_command_completed,
-- unit_number :: uint: unit_number/group_number of the unit/group which just completed a command.
-- result :: defines.behavior_result
	-- 0: defines.behavior_result.in_progress
	-- 1: defines.behavior_result.fail
	-- 2: defines.behavior_result.success
	-- 3: defines.behavior_result.deleted
-- was_distracted :: boolean: Was this command generated by a distraction.
function(event)
   if (global.TrackingLists.NumberToColonistName[event.unit_number]) then
      local ColonistProperties = global.AllColonists[global.TrackingLists.NumberToColonistName[event.unit_number]]
      local colonist = ColonistProperties.entity
   	if (ColonistProperties and colonist.valid) then
   		if (ColonistProperties.ActionPlan.state == "executing") then -- if running an action queue
            local ExecutingAction = ColonistProperties.ActionPlan.queue[#ColonistProperties.ActionPlan.queue]
   			if (event.result == 2) then -- success
   				-- colonist successfully completed the goto action, set to complete for StepActionQueue() processing
               ExecutingAction.status = "completed"
   			elseif (event.result == 1) then -- failure. For some reason, dying triggers this
   				--game.print(ColonistProperties.name..": The object I was moving to for "..ColonistProperties.ActionPlan.queue[ExecutingAction.ParentAction].name.." was removed")
               if (ExecutingAction.optional and ExecutingAction.optional == true) then
                  ExecutingAction.status = "completed"
               else
                  ColonistProperties.ActionPlan.state = "interrupted"
               end
   			end
   		end
   	end
   end
end)

script.on_event(defines.events.on_entity_died,
-- entity :: LuaEntity The entity that died.
-- cause :: LuaEntity? The entity that did the killing if available.
function(event)
   if (global.AllColonists[event.entity.unit_number]) then
      global.AllColonists[event.entity.unit_number].ActionPlan.state = "interrupted"
      global.AllColonists[event.entity.unit_number].alive = false
   end
end)

script.on_event("ClickTracking",
	require("script.ClickTracking")
)
script.on_event(defines.events.on_gui_opened,
	require("script.GUI_Stuff.OpenGUI")
)
script.on_event(defines.events.on_gui_closed,
	require("script.GUI_Stuff.CloseGUI")
)
script.on_event(defines.events.on_gui_click,
	require("script.GUI_Stuff.ClickGUI")
)
script.on_event(defines.events.on_gui_elem_changed,
-- element
-- player_index
function(event)
   local player = game.players[event.player_index]
   if (string.find(event.element.name, "ItemCrafting")) then
      local properties = global.workplaces[player.force.name][player.surface.name][event.element.tags.entity]
         properties.DropOffLinks[event.element.tags.slot].item = event.element.elem_value
   end
end)
